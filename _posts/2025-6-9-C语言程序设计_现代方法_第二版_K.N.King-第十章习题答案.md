---
layout: article
title: C语言程序设计_现代方法_第二版_K.N.King-第十章习题答案
---
## 练习题
### 10.4节
#### 1
（a）b，c,a
（b）d，e,a
（c）
```c
{
	int e
}
```
(d)f,a
#### 2
(a)b是f内部的,d,c
（b）a是形参，c是g内部，a是另一个，d，b
（c）a，d，b
（d）b,d,c是内部的
#### 3
内存范围内，可以定义无数个
## 编程题
#### 1
```c
{#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h> /* C99 only */
#include <stdlib.h>

#define STACK_SIZE 100

/* external variables */
char contents[STACK_SIZE];
int top = 0;

void make_empty(void)
{
    top = 0;
}

bool is_empty(void)
{
    return top == 0;
}

bool is_full(void)
{
    return top == STACK_SIZE;
}

void stack_overflow(void)
{
    printf("Stack overflow\n");
    exit(EXIT_FAILURE);
}

void stack_underflow(void)
{
    printf("Stack underflow\n");
    exit(EXIT_FAILURE);
}

void push(char ch)
{
    if (is_full())
        stack_overflow();
    else
        contents[top++] = ch;
}

char pop(void)
{
    if (is_empty())
        stack_underflow();
    else
        return contents[--top];
}

int main(void)
{
    char ch;

    printf("Enter parentheses and/or braces: ");

    while ((ch = getchar()) != '\n')
    {
        if (ch == '(' || ch == '{') 
        {
            push(ch);
        }else if (ch == ')' || ch == '}') 
        {
            if (is_empty()) {
                printf("Parentheses/braces are NOT nested properly\n");
                return 0;
            }

            char popped = pop();
            if ((ch == ')' && popped != '(') || (ch == '}' && popped != '{')) {
                printf("Parentheses/braces are NOT nested properly\n");
                return 0;
            }
        }
        // 忽略其他字符，只处理括号
    }

    if (is_empty()) {
        printf("Parentheses/braces are nested properly\n");
    }
    else {
        printf("Parentheses/braces are NOT nested properly\n");
    }

    return 0;
}
}
```
#### 2
```c
{
#define _CRT_SECURE_NO_WARNINGS
/* Classifies a poker hand */
#include <stdbool.h> /* C99 only */ 
#include <stdio.h> 
#include <stdlib.h> 
#define NUM_RANKS 13 
#define NUM_SUITS 4 
#define NUM_CARDS 5 
/* external variables */
bool straight, flush, four, three;
int pairs; /* can be 0, 1, or 2 */
/* prototypes */
void read_cards(int num_in_rank[NUM_RANKS], int num_in_suit[NUM_SUITS]);
void analyze_hand(int num_in_rank[NUM_RANKS], int num_in_suit[NUM_SUITS]);
void print_result(void);
/************************************************************
 * main: Calls read_cards, analyze_hand, and print_result *
 * repeatedly. *
 ************************************************************/
int main(void)
{
	int num_in_rank[NUM_RANKS];
	int num_in_suit[NUM_SUITS];
	for (;;) {
		read_cards(num_in_rank, num_in_suit);
		analyze_hand(num_in_rank, num_in_suit);
		print_result();
	}
}
/************************************************************
 * read_cards: Reads the cards into the external *
 * variables num_in_rank and num_in_suit; *
 * checks for bad cards and duplicate cards. *
 ************************************************************/
void read_cards(int num_in_rank[NUM_RANKS],int num_in_suit[NUM_SUITS])
{
	bool card_exists[NUM_RANKS][NUM_SUITS];
	char ch, rank_ch, suit_ch;
	int rank, suit;
	bool bad_card;
	int cards_read = 0;
	for (rank = 0; rank < NUM_RANKS; rank++) 
	{
		num_in_rank[rank] = 0;
		for (suit = 0; suit < NUM_SUITS; suit++)
			card_exists[rank][suit] = false;
	}
	for (suit = 0; suit < NUM_SUITS; suit++)
		num_in_suit[suit] = 0;
	while (cards_read < NUM_CARDS) {
		bad_card = false;
		printf("Enter a card: ");
		rank_ch = getchar();
		switch (rank_ch) {
		case '0': exit(EXIT_SUCCESS);
		case '2': rank = 0; break;
		case '3': rank = 1; break;
		case '4': rank = 2; break;
		case '5': rank = 3; break;
		case '6': rank = 4; break;
		case '7': rank = 5; break;
		case '8': rank = 6; break;
		case '9': rank = 7; break;
		case 't': case 'T': rank = 8; break;
		case 'j': case 'J': rank = 9; break;
		case 'q': case 'Q': rank = 10; break;
		case 'k': case 'K': rank = 11; break;
		case 'a': case 'A': rank = 12; break;
		default: bad_card = true;
		}
		suit_ch = getchar();
		switch (suit_ch) {
		case 'c': case 'C': suit = 0; break;
		case 'd': case 'D': suit = 1; break;
		case 'h': case 'H': suit = 2; break;
		case 's': case 'S': suit = 3; break;
		default: bad_card = true;
		}
		while ((ch = getchar()) != '\n')
			if (ch != ' ') bad_card = true;
		if (bad_card)
			printf("Bad card; ignored.\n");
		else if (card_exists[rank][suit])
			printf("Duplicate card; ignored.\n");
		else {
			num_in_rank[rank]++;
			num_in_suit[suit]++;
			card_exists[rank][suit] = true;
			cards_read++;
		}
	}
}
/************************************************************
 * analyze_hand: Determines whether the hand contains a *
 * straight, a flush, four-of-a-kind, *
 * and/or three-of-a-kind; determines the *
 * number of pairs; stores the results into *
 * the external variables straight, flush, *
 * four, three, and pairs. *
 ************************************************************/
void analyze_hand(int num_in_rank[NUM_RANKS], int num_in_suit[NUM_SUITS])
{
	int num_consec = 0;
	int rank, suit;
	straight = false;
	flush = false;
	four = false;
	three = false;
	pairs = 0;
	/* check for flush */
	for (suit = 0; suit < NUM_SUITS; suit++)
		if (num_in_suit[suit] == NUM_CARDS)
			flush = true;
	/* check for straight */
	rank = 0;
	while (num_in_rank[rank] == 0) rank++;
	for (; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
		num_consec++;
	if (num_consec == NUM_CARDS) {
		straight = true;
		return;
	}
	/* check for 4-of-a-kind, 3-of-a-kind, and pairs */
	for (rank = 0; rank < NUM_RANKS; rank++) {
		if (num_in_rank[rank] == 4) four = true;
		if (num_in_rank[rank] == 3) three = true;
		if (num_in_rank[rank] == 2) pairs++;
	}
}
/************************************************************
 * print_result: prints the classification of the hand, *
 * based on the values of the external *
 * variables straight, flush, four, three, *
 * and pairs. *
 ************************************************************/
void print_result(void)
{
	if (straight && flush) printf("Straight flush");
	else if (four) printf("Four of a kind");
	else if (three &&
		pairs == 1) printf("Full house");
	else if (flush) printf("Flush");
	else if (straight) printf("Straight");
	else if (three) printf("Three of a kind");
	else if (pairs == 2) printf("Two pairs");
	else if (pairs == 1) printf("Pair");
	else printf("High card");
	printf("\n\n");
}

}
```
#### 3
```c
{
#define _CRT_SECURE_NO_WARNINGS
/* Classifies a poker hand */
#include <stdbool.h> /* C99 only */ 
#include <stdio.h> 
#include <stdlib.h> 
#define NUM_RANKS 13 
#define NUM_SUITS 4 
#define NUM_CARDS 5 

/* external variables */
bool straight, flush, four, three;
int pairs; /* can be 0, 1, or 2 */

/* prototypes */
void read_cards(int hand[NUM_CARDS][2]);
void analyze_hand(int hand[NUM_CARDS][2]);
void print_result(void);

/************************************************************
 * main: Calls read_cards, analyze_hand, and print_result *
 * repeatedly. *
 ************************************************************/
int main(void)
{
    int hand[NUM_CARDS][2]; /* hand[i][0] = rank, hand[i][1] = suit */
    
    for (;;) {
        read_cards(hand);
        analyze_hand(hand);
        print_result();
    }
}

/************************************************************
 * read_cards: Reads the cards into the hand array *
 * checks for bad cards and duplicate cards. *
 ************************************************************/
void read_cards(int hand[NUM_CARDS][2])
{
    char ch, rank_ch, suit_ch;
    int rank, suit;
    bool bad_card;
    int cards_read = 0;
    
    while (cards_read < NUM_CARDS) {
        bad_card = false;
        printf("Enter a card: ");
        
        rank_ch = getchar();
        switch (rank_ch) {
            case '0': exit(EXIT_SUCCESS);
            case '2': rank = 0; break;
            case '3': rank = 1; break;
            case '4': rank = 2; break;
            case '5': rank = 3; break;
            case '6': rank = 4; break;
            case '7': rank = 5; break;
            case '8': rank = 6; break;
            case '9': rank = 7; break;
            case 't': case 'T': rank = 8; break;
            case 'j': case 'J': rank = 9; break;
            case 'q': case 'Q': rank = 10; break;
            case 'k': case 'K': rank = 11; break;
            case 'a': case 'A': rank = 12; break;
            default: bad_card = true;
        }
        
        suit_ch = getchar();
        switch (suit_ch) {
            case 'c': case 'C': suit = 0; break;
            case 'd': case 'D': suit = 1; break;
            case 'h': case 'H': suit = 2; break;
            case 's': case 'S': suit = 3; break;
            default: bad_card = true;
        }
        
        while ((ch = getchar()) != '\n')
            if (ch != ' ') bad_card = true;
        
        if (bad_card) {
            printf("Bad card; ignored.\n");
            continue;
        }
        
        /* Check for duplicate card */
        bool duplicate = false;
        for (int i = 0; i < cards_read; i++) {
            if (hand[i][0] == rank && hand[i][1] == suit) {
                duplicate = true;
                break;
            }
        }
        
        if (duplicate) {
            printf("Duplicate card; ignored.\n");
        } else {
            hand[cards_read][0] = rank;
            hand[cards_read][1] = suit;
            cards_read++;
        }
    }
}

/************************************************************
 * analyze_hand: Determines whether the hand contains a *
 * straight, a flush, four-of-a-kind, *
 * and/or three-of-a-kind; determines the *
 * number of pairs; stores the results into *
 * the external variables straight, flush, *
 * four, three, and pairs. *
 ************************************************************/
void analyze_hand(int hand[NUM_CARDS][2])
{
    int num_in_rank[NUM_RANKS] = {0};
    int num_in_suit[NUM_SUITS] = {0};
    int num_consec = 0;
    int rank, suit;
    
    straight = false;
    flush = false;
    four = false;
    three = false;
    pairs = 0;
    
    /* Count ranks and suits from hand array */
    for (int i = 0; i < NUM_CARDS; i++) {
        rank = hand[i][0];
        suit = hand[i][1];
        num_in_rank[rank]++;
        num_in_suit[suit]++;
    }
    
    /* check for flush */
    for (suit = 0; suit < NUM_SUITS; suit++)
        if (num_in_suit[suit] == NUM_CARDS)
            flush = true;
    
    /* check for straight */
    rank = 0;
    while (num_in_rank[rank] == 0) rank++;
    for (; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
        num_consec++;
    
    if (num_consec == NUM_CARDS) {
        straight = true;
        return;
    }
    
    /* check for 4-of-a-kind, 3-of-a-kind, and pairs */
    for (rank = 0; rank < NUM_RANKS; rank++) {
        if (num_in_rank[rank] == 4) four = true;
        if (num_in_rank[rank] == 3) three = true;
        if (num_in_rank[rank] == 2) pairs++;
    }
}

/************************************************************
 * print_result: prints the classification of the hand, *
 * based on the values of the external *
 * variables straight, flush, four, three, *
 * and pairs. *
 ************************************************************/
void print_result(void)
{
    if (straight && flush) printf("Straight flush");
    else if (four) printf("Four of a kind");
    else if (three && pairs == 1) printf("Full house");
    else if (flush) printf("Flush");
    else if (straight) printf("Straight");
    else if (three) printf("Three of a kind");
    else if (pairs == 2) printf("Two pairs");
    else if (pairs == 1) printf("Pair");
    else printf("High card");
    printf("\n\n");
}
}
```
#### 4
```c
{
#define _CRT_SECURE_NO_WARNINGS
/* Classifies a poker hand */
#include <stdbool.h> /* C99 only */ 
#include <stdio.h> 
#include <stdlib.h> 
#define NUM_RANKS 13 
#define NUM_SUITS 4 
#define NUM_CARDS 5 

/* external variables */
bool straight, flush, four, three, royal_flush;
int pairs; /* can be 0, 1, or 2 */

/* prototypes */
void read_cards(int hand[NUM_CARDS][2]);
void analyze_hand(int hand[NUM_CARDS][2]);
void print_result(void);

/************************************************************
 * main: Calls read_cards, analyze_hand, and print_result *
 * repeatedly. *
 ************************************************************/
int main(void)
{
    int hand[NUM_CARDS][2]; /* hand[i][0] = rank, hand[i][1] = suit */
    
    for (;;) {
        read_cards(hand);
        analyze_hand(hand);
        print_result();
    }
}

/************************************************************
 * read_cards: Reads the cards into the hand array *
 * checks for bad cards and duplicate cards. *
 ************************************************************/
void read_cards(int hand[NUM_CARDS][2])
{
    char ch, rank_ch, suit_ch;
    int rank, suit;
    bool bad_card;
    int cards_read = 0;
    
    while (cards_read < NUM_CARDS) {
        bad_card = false;
        printf("Enter a card: ");
        
        rank_ch = getchar();
        switch (rank_ch) {
            case '0': exit(EXIT_SUCCESS);
            case '2': rank = 0; break;
            case '3': rank = 1; break;
            case '4': rank = 2; break;
            case '5': rank = 3; break;
            case '6': rank = 4; break;
            case '7': rank = 5; break;
            case '8': rank = 6; break;
            case '9': rank = 7; break;
            case 't': case 'T': rank = 8; break;  /* 10 */
            case 'j': case 'J': rank = 9; break;  /* J */
            case 'q': case 'Q': rank = 10; break; /* Q */
            case 'k': case 'K': rank = 11; break; /* K */
            case 'a': case 'A': rank = 12; break; /* A */
            default: bad_card = true;
        }
        
        suit_ch = getchar();
        switch (suit_ch) {
            case 'c': case 'C': suit = 0; break;
            case 'd': case 'D': suit = 1; break;
            case 'h': case 'H': suit = 2; break;
            case 's': case 'S': suit = 3; break;
            default: bad_card = true;
        }
        
        while ((ch = getchar()) != '\n')
            if (ch != ' ') bad_card = true;
        
        if (bad_card) {
            printf("Bad card; ignored.\n");
            continue;
        }
        
        /* Check for duplicate card */
        bool duplicate = false;
        for (int i = 0; i < cards_read; i++) {
            if (hand[i][0] == rank && hand[i][1] == suit) {
                duplicate = true;
                break;
            }
        }
        
        if (duplicate) {
            printf("Duplicate card; ignored.\n");
        } else {
            hand[cards_read][0] = rank;
            hand[cards_read][1] = suit;
            cards_read++;
        }
    }
}

/************************************************************
 * analyze_hand: Determines whether the hand contains a *
 * straight, a flush, four-of-a-kind, *
 * and/or three-of-a-kind; determines the *
 * number of pairs; stores the results into *
 * the external variables straight, flush, *
 * four, three, and pairs. *
 ************************************************************/
void analyze_hand(int hand[NUM_CARDS][2])
{
    int num_in_rank[NUM_RANKS] = {0};
    int num_in_suit[NUM_SUITS] = {0};
    int num_consec = 0;
    int rank, suit;
    int min_rank = NUM_RANKS - 1;
    int max_rank = 0;
    
    /* Initialize all flags */
    straight = false;
    flush = false;
    four = false;
    three = false;
    royal_flush = false;
    pairs = 0;
    
    /* Count ranks and suits from hand array */
    for (int i = 0; i < NUM_CARDS; i++) {
        rank = hand[i][0];
        suit = hand[i][1];
        num_in_rank[rank]++;
        num_in_suit[suit]++;
        
        /* Track min and max rank for straight check */
        if (rank < min_rank) min_rank = rank;
        if (rank > max_rank) max_rank = rank;
    }
    
    /* check for flush */
    for (suit = 0; suit < NUM_SUITS; suit++)
        if (num_in_suit[suit] == NUM_CARDS)
            flush = true;
    
    /* check for straight */
    /* Method 1: Check for consecutive ranks */
    rank = 0;
    while (num_in_rank[rank] == 0) rank++;
    for (; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
        num_consec++;
    
    if (num_consec == NUM_CARDS) {
        straight = true;
        
        /* Check for royal flush (A, K, Q, J, 10 of same suit) */
        if (flush && max_rank == 12 && min_rank == 8) {
            royal_flush = true;
        }
        return;
    }
    
    /* Method 2: Check if max_rank - min_rank == 4 and all ranks are different */
    if (max_rank - min_rank == 4) {
        bool all_different = true;
        for (rank = min_rank; rank <= max_rank; rank++) {
            if (num_in_rank[rank] != 1) {
                all_different = false;
                break;
            }
        }
        if (all_different) {
            straight = true;
            
            /* Check for royal flush (special case: A, 2, 3, 4, 5 not royal) */
            if (flush && max_rank == 12 && min_rank == 0) {
                /* This is A,2,3,4,5 straight, not royal flush */
            } else if (flush && max_rank == 12 && min_rank == 8) {
                /* This is 10,J,Q,K,A straight of same suit - ROYAL FLUSH! */
                royal_flush = true;
            }
            return;
        }
    }
    
    /* check for 4-of-a-kind, 3-of-a-kind, and pairs */
    for (rank = 0; rank < NUM_RANKS; rank++) {
        if (num_in_rank[rank] == 4) four = true;
        if (num_in_rank[rank] == 3) three = true;
        if (num_in_rank[rank] == 2) pairs++;
    }
}

/************************************************************
 * print_result: prints the classification of the hand, *
 * based on the values of the external *
 * variables straight, flush, four, three, *
 * and pairs. *
 ************************************************************/
void print_result(void)
{
    if (royal_flush) 
        printf("Royal flush");
    else if (straight && flush) 
        printf("Straight flush");
    else if (four) 
        printf("Four of a kind");
    else if (three && pairs == 1) 
        printf("Full house");
    else if (flush) 
        printf("Flush");
    else if (straight) 
        printf("Straight");
    else if (three) 
        printf("Three of a kind");
    else if (pairs == 2) 
        printf("Two pairs");
    else if (pairs == 1) 
        printf("Pair");
    else 
        printf("High card");
    
    printf("\n\n");
}
}
```
#### 5
略
#### 6
```c
{
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>

#define STACK_SIZE 100

/* 栈实现 */
int contents[STACK_SIZE];
int top = 0;

void make_empty(void)
{
    top = 0;
}

bool is_empty(void)
{
    return top == 0;
}

bool is_full(void)
{
    return top == STACK_SIZE;
}

void stack_overflow(void)
{
    printf("Expression is too complex\n");
    exit(EXIT_FAILURE);
}

void stack_underflow(void)
{
    printf("Not enough operands in expression\n");
    exit(EXIT_FAILURE);
}

void push(int i)
{
    if (is_full())
        stack_overflow();
    else
        contents[top++] = i;
}

int pop(void)
{
    if (is_empty())
        stack_underflow();
    else
        return contents[--top];
}

/* RPN计算器主程序 */
int main(void)
{
    char ch;
    int operand1, operand2, result;
    
    printf("Enter an RPN expression: ");
    
    while (1) {
        scanf(" %c", &ch);
        
        if (isdigit(ch)) {
            // 遇到操作数，压入栈中
            push(ch - '0');
        }
        else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
            // 遇到运算符，从栈中弹出操作数进行计算
            operand2 = pop();
            operand1 = pop();
            
            switch (ch) {
                case '+':
                    result = operand1 + operand2;
                    break;
                case '-':
                    result = operand1 - operand2;
                    break;
                case '*':
                    result = operand1 * operand2;
                    break;
                case '/':
                    if (operand2 == 0) {
                        printf("Error: Division by zero\n");
                        exit(EXIT_FAILURE);
                    }
                    result = operand1 / operand2;
                    break;
            }
            
            push(result);
        }
        else if (ch == '=') {
            // 遇到等号，显示结果并清空栈
            if (top != 1) {
                printf("Error: Too many operands left\n");
                exit(EXIT_FAILURE);
            }
            
            result = pop();
            printf("Value of expression: %d\n", result);
            
            // 清空栈
            make_empty();
            
            // 提示输入新的表达式
            printf("Enter an RPN expression: ");
        }
        else if (ch == 'q' || ch == 'Q') {
            // 退出程序
            break;
        }
        else {
            // 非法字符
            printf("Error: Invalid character '%c'\n", ch);
            exit(EXIT_FAILURE);
        }
    }
    
    return 0;
}
}
```
#### 7
略
