---
layout: article
title: C语言程序设计_现代方法_第二版_K.N.King-第八章习题答案
---
## 练习题
### 8.1 1
因为数组的类型会因为后期修改而变化，使用后者不方便
### 8.1 2
与用字符作为下标类似，需要保证数字字符所代表的数值在规定范围内
### 8.1 3
```c
bool weekend[7] = { true,false,false,false,false,false,true };
//C99
```
### 8.1 4
```c
bool weekend[7] = { [0]=true,[6]=true };
//C99
```
### 8.1 5
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	long a[40] = { 0 };
	a[0] = 0;
	a[1] = 1;
	int i = 0;
	int j = 2;
	while (j <= 39)
	{
		a[j] = a[i] + a[i + 1];
		j++;
		i++;
	}
	for (int k = 0; k < 40; k++)
	{
		printf("%ld ", a[k]);
	}
    return 0;  
}
```
### 8.2 6
```c
const int segments[10][7] = { {1,1,1,1,1,1,0},{0,1,1,0,0,0,0},{1,1,0,1,1,0,1},{1,1,1,1,0,0,1},{0,1,1,0,0,1,1},之后类似，};
```
### 8.2 7
```c
const int segments[10][7] = { [0][0]=1,[0][1]=1,[0][2]=1,[0][3]=1,[0][4]=1,[0][5]=1,[1][1]=1,[1][2]=1,[2][0]=1,[2][1]=1,[2][3]=1,[2][4]=1,[2][6]=1,之后类似};
```
### 8.2 8
```c
const double temperature_readings[30][24]={0};
```
### 8.2 9
```c
for(int i=0;i<30;i++)
{
    for(int j=0;j<24;j++)
    {
	    sum=sum+a[i][j];
    }
}
res=sum/(30*24);
```
### 8.2 10
略
### 8.2 11
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	char buffer[8][8] = {0};
	for (int i = 0; i < 8; i++)
	{
		for(int j = 0; j < 8; j++)
		{
			if((i + j) % 2 == 0)
				buffer[i][j] = 'B';
			else
			buffer[i][j] = 'R';
		}
	}
	for (int i = 0; i < 8; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			printf("%c ", buffer[i][j]);
		}
		printf("\n");
	}
    return 0;  
}
```
## 编程题
### 1
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
int main() {
	bool digit_seen[10] = { false };
	int digit;
	long n;
	printf("Enter an integer: ");
	scanf("%ld", &n);
	while (n > 0)
	{
		digit = n % 10;
		if(digit_seen[digit] == true) 
		{
			printf("Repeated digit: %d\n", digit);
		}
		digit_seen[digit] = true;
		n = n / 10;
	}
	
    return 0;  
}
```
### 2
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
int main() {
	bool digit_seen[10] = { false };
	int digit;
	long n;
	int Digit[10] = {0,1,2,3,4,5,6,7,8,9};
	int occurrences[10] = { 0 };
	printf("Enter an integer: ");
	scanf("%ld", &n);
	while (n > 0)
	{
		digit = n % 10;
		occurrences[digit]++;
		
		digit_seen[digit] = true;
		n = n / 10;
	}
	for (int i = 0; i < 10; i++)
	{
		printf("%d ",Digit[i]);
	}
	printf("\n");
	for (int i = 0; i < 10; i++)
	{
		printf("%d ",occurrences[i]);
	}
    return 0;  
}
```
### 3
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
int main() {
	bool digit_seen[10] = { false };
	int digit;
	long n;
	printf("Enter an integer: ");
	scanf("%ld", &n);
	while (n > 0)
	{
		while (n > 0)
		{
			digit = n % 10;
			if (digit_seen[digit] == true)
			{
				printf("Repeated digit: %d\n", digit);
			}
			digit_seen[digit] = true;
			n = n / 10;
		}
		for (int i = 0; i < 10; i++)
		{
			digit_seen[i] = false;
		}
		printf("Enter an integer: ");
		scanf("%ld", &n);
	}
	return 0;
}
```
### 4
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
#define N 10
int main(void)
{
	int a[N], i;
	printf("Enter %d numbers: ", N);
	for (i = 0; i < (int)(sizeof(a)/sizeof(a[0])); i++)
		scanf("%d", &a[i]);
	printf("In reverse order:");
	for (i = (int)(sizeof(a) / sizeof(a[0])) - 1; i >= 0; i--)
		printf(" %d", a[i]);
	printf("\n");
	return 0;
}
```
### 5
略
### 6
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
#include <ctype.h>

#define MAX_LENGTH 100
#define EXCLAMATION_COUNT 10

int main(void) {
    char message[MAX_LENGTH];
    int i = 0;

    printf("Enter message: ");
    fgets(message, MAX_LENGTH, stdin);

    printf("In B1FF-speak: ");

    // 遍历输入的每个字符并进行转换
    while (message[i] != '\0' && message[i] != '\n') {
        char ch = toupper(message[i]);  // 先转换为大写

        // 根据规则替换特定字符
        switch (ch) {
        case 'A': putchar('4'); break;
        case 'B': putchar('8'); break;
        case 'E': putchar('3'); break;
        case 'I': putchar('1'); break;
        case 'O': putchar('0'); break;
        case 'S': putchar('5'); break;
        default: putchar(ch); break;  // 其他字符保持原样（大写后）
        }
        i++;
    }

    // 添加10个感叹号
    for (i = 0; i < EXCLAMATION_COUNT; i++) {
        putchar('!');
    }
    putchar('\n');

    return 0;
}
```
### 7
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
int main(void)
{
	int a[5][5] = { 0 };
	for(int i=0; i < 5; i++)
	{
		for(int j = 0; j < 5; j++)
		{
			scanf("%d", &a[i][j]);
		}
	}
	int row_sum = 0, col_sum = 0;
	for(int i=0; i < 5; i++)
	{
		for(int j = 0; j < 5; j++)
		{
			row_sum += a[i][j];
			col_sum += a[j][i];
		}
		printf("%d ", row_sum);
		printf("%d ", col_sum);
		row_sum = 0;
		col_sum = 0;
		printf("\n");
	}
}
```
### 8
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
int main(void)
{
	int a[5][5] = { 0 };
	for(int i=0; i < 5; i++)
	{
		for(int j = 0; j < 5; j++)
		{
			scanf("%d", &a[i][j]);
		}
	}
	int row_sum = 0, col_sum = 0;
	int max_score = 0, min_score = 100;
	for(int i=0; i < 5; i++)
	{
		for(int j = 0; j < 5; j++)
		{
			if(a[j][i] > max_score)
				max_score = a[j][i];
			if (a[j][i] < min_score)
				min_score = a[j][i];
			row_sum += a[i][j];
			col_sum += a[j][i];
		}
		printf("student total score is %d  average score is %d\n", row_sum, row_sum / 5);
		printf("student max score is %d  min score is %d\n", max_score, min_score);
		row_sum = 0;
		col_sum = 0;
		min_score = 100;
		max_score = 0;
		printf("\n");
	}
}


```
### 9
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
#include <time.h>
#include <stdlib.h>

#define SIZE 10
#define DIRECTIONS 4

int main(void) {
    char grid[SIZE][SIZE];
    int x = 0, y = 0;
    int direction, new_x, new_y;
    int moves_tried;
    char current_char = 'A';

    // 初始化随机数种子
    srand((unsigned)time(NULL));

    // 初始化网格为'.'
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            grid[i][j] = '.';
        }
    }

    // 从(0,0)开始
    grid[x][y] = current_char++;

    // 随机行走直到Z或者被卡住
    while (current_char <= 'Z') {
        int possible_directions[DIRECTIONS] = { 0, 1, 2, 3 }; // 0:上, 1:下, 2:左, 3:右
        int tried[DIRECTIONS] = { 0 }; // 记录哪些方向已经尝试过
        moves_tried = 0;

        // 随机尝试四个方向
        while (moves_tried < DIRECTIONS) {
            // 随机选择一个未尝试的方向
            int rand_index;
            do {
                rand_index = rand() % DIRECTIONS;
            } while (tried[rand_index]);

            direction = possible_directions[rand_index];
            tried[rand_index] = 1;
            moves_tried++;

            // 计算新位置
            new_x = x;
            new_y = y;

            switch (direction) {
            case 0: // 上
                new_x--;
                break;
            case 1: // 下
                new_x++;
                break;
            case 2: // 左
                new_y--;
                break;
            case 3: // 右
                new_y++;
                break;
            }

            // 检查新位置是否有效
            if (new_x >= 0 && new_x < SIZE &&
                new_y >= 0 && new_y < SIZE &&
                grid[new_x][new_y] == '.') {
                // 移动到新位置
                x = new_x;
                y = new_y;
                grid[x][y] = current_char++;
                break; // 成功移动，跳出内层循环
            }
        }

        // 如果四个方向都尝试过且都不能移动，则终止
        if (moves_tried == DIRECTIONS) {
            break;
        }
    }

    // 打印最终的网格
    printf("最终的随机步法网格:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%c ", grid[i][j]);
        }
        printf("\n");
    }

    printf("\n到达的字母: A 到 %c\n", current_char - 1);

    return 0;
}


```
### 10
略
### 11
略
### 12
略
### 13
略
### 14
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define MAX_LENGTH 100

int main(void) {
    char sentence[MAX_LENGTH];
    char terminator = '\0';  // 终止字符
    int length = 0;

    // 读取句子
    printf("Enter a sentence: ");

    // 读取字符直到遇到终止字符
    while (length < MAX_LENGTH - 1) {
        char ch = getchar();

        // 检查是否为终止字符
        if (ch == '.' || ch == '?' || ch == '!') {
            terminator = ch;
            break;
        }

        sentence[length++] = ch;
    }
    sentence[length] = '\0';  // 字符串结束

    // 反向搜索并打印单词
    printf("Reversal of sentence: ");

    int end = length;  // 当前搜索的结束位置（从末尾开始）

    while (end > 0) {
        // 找到单词的开始位置
        int start = end - 1;
        while (start >= 0 && sentence[start] != ' ') {
            start--;
        }

        // 打印单词（start可能是-1或空格位置）
        for (int i = start + 1; i < end; i++) {
            putchar(sentence[i]);
        }

        // 如果不是第一个单词，打印空格
        if (start > 0) {
            putchar(' ');
        }

        // 更新end到下一个单词的起始位置之前
        end = start;
    }

    // 打印终止字符
    if (terminator != '\0') {
        putchar(terminator);
    }
    putchar('\n');

    return 0;
}
```
### 15
略
### 16
```c
#include <stdio.h>
#include <ctype.h>
#define _CRT_SECURE_NO_WARNINGS
#define ALPHABET_SIZE 26

int main(void) {
    char ch;
    int letter_count[ALPHABET_SIZE] = {0};
    
    // 读取并统计第一个单词
    printf("Enter first word: ");
    while ((ch = getchar()) != '\n' && ch != EOF) {
        if (isalpha(ch)) {
            ch = tolower(ch);
            letter_count[ch - 'a']++;
        }
    }
    
    // 读取第二个单词并减去计数
    printf("Enter second word: ");
    while ((ch = getchar()) != '\n' && ch != EOF) {
        if (isalpha(ch)) {
            ch = tolower(ch);
            letter_count[ch - 'a']--;
        }
    }
    
    // 检查数组是否全为0
    int is_anagram = 1;  // 假设是变位词
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        if (letter_count[i] != 0) {
            is_anagram = 0;  // 不是变位词
            break;
        }
    }
    
    // 输出结果
    if (is_anagram) {
        printf("The words are anagrams.\n");
    } else {
        printf("The words are not anagrams.\n");
    }
    
    return 0;
}
```
### 17
略