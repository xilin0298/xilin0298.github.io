---
layout: article
title: C语言程序设计_现代方法_第二版_K.N.King-第九章习题答案
---
## 练习题
### 9.1
#### 1
```c
double triangle_area(double base,double height) 
{ 
 double product; 
 product = base * height; 
 return product / 2; 
} 
```
#### 2
```c
int check(int x,int y,int n)
{
	if(x>=0&&x<=(n-1)&&y>=0&&y<=(n-1))
	{
		return 1;
	}else
	{
		return 0;
	}
}
```
#### 3
```c
int gcd(int m,int n)
{
	while (1) {
		if (n == 0) {
			printf("最大公约数是：%d\n", m);
			return m;
		}
		else {
			int remainder = m % n;
			m = n;
			n = remainder;
		}
	}
}
```
#### 4
略
#### 5
```c
int num_digit(int n)
{
	int count=0;
	while(n!=0)
	{
		n=n/10;
		count++;
	}
	return count;
}
```
#### 6
```c
int digit(int n,int k)
{
	int res;
	for(int i=0;i<k;i++)
	{
		res=n%10;
		if(n==0)
		{
			return 0;
		}else
		{
			return res;
		}
		n=n/10;
	}
}
```
#### 7
如果忽略隐式转换，那么都合法
### 9.2节
#### 8
（a）（b）是正确的，c没有形参类型，d默认返回类型为int
### 9.3节
#### 9
i = 1，j = 2
#### 10
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define LENGTH 3
int find_max(int, int a[]);
int find_average(int, int a[]);
int statistical_elements(int, int a[]);
int main(void) {
	int a[LENGTH] = { 10, 20, 30 };
	int max = find_max(LENGTH, a);
	printf("The maximum value is: %d\n", max);
	int average = find_average(LENGTH, a);
	printf("The average value is: %d\n", average);
	int stats = statistical_elements(LENGTH, a);
	printf("The statistical elements value is: %d\n", stats);
    return 0;
}
int find_max(int, int a[])
{
	int max=0;
	for(int i = 0; i < LENGTH; i++) {
		if(a[i] > max) {
			max = a[i];
		}
	}
	return max;
}
int find_average(int, int a[])
{
	int sum = 0;
	for(int i = 0; i < LENGTH; i++) {
		sum += a[i];
	}
	return sum / LENGTH;
}
int statistical_elements(int, int a[])
{
	int total = 0;
	for(int i = 0; i < LENGTH; i++) {
		total += 1;
	}
	return total;
}
```
#### 11
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define LENGTH 5
float compute_GPA(char grades[], int n);
int main(void) {
	char grades[LENGTH] = {'A','B','C','D','F'};
	int average_grade = compute_GPA(grades, LENGTH);
	printf("The average grade is: %d\n", average_grade);
}
float compute_GPA(char grades[], int n) {
	int total = 0;
	for (int i = 0; i < n; i++) {
		switch (grades[i]) {
		case 'A':
			total += 4;
			break;
		case 'B':
			total += 3;
			break;
		case 'C':
			total += 2;
			break;
		case 'D':
			total += 1;
			break;
		case 'F':
			total += 0;
			break;
		default:
			printf("Invalid grade: %c\n", grades[i]);
		}
	}
	return (float)total / n;
}
```
#### 12
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define LENGTH 3
double inner_product(double a[], double b[], int n);
int main(void) {
	double a[LENGTH] = { 1.0,2.0,3.0 };
	double b[LENGTH] = { 1.0,2.0,3.0 };
	double result = inner_product(a, b, LENGTH);
	printf("Inner product: %g\n", result);
}
double inner_product(double a[], double b[], int n) {
	double result = 0.0;
	for (int i = 0; i < n; i++) {
		result += a[i] * b[i];
	}
	return result;
}

```
#### 13
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define LENGTH 6
int evaluate_position(char board[6][6]);
int main(void) {
	char space[LENGTH][LENGTH] = { {'K','Q'},{ 'k','n','p'},{'R','B','N','P'} ,{'q','r','b'} };
	
	if (evaluate_position(space) > 0)
	{
		printf("White is better\n");
	}
	else if (evaluate_position(space) < 0)
	{
		printf("Black is better\n");
	}
	else
	{
		printf("Equal position\n");
	}
}
int evaluate_position(char board[6][6])
{
	int white_score = 0;
	int black_score = 0;
	for(int i=0;i<LENGTH;i++)
	{
		for(int j=0;j<LENGTH;j++)
		{
			switch (board[i][j])
			{
			case 'P':
				white_score += 1;
				break;
			case 'p':
				black_score += 1;
				break;
			case 'Q':
				white_score += 9;
				break;
			case 'q':
				black_score += 9;
				break;
			case 'R':
				white_score += 5;
				break;
			case 'r':
				black_score += 5;
				break;
			case 'B':
				white_score += 3;
				break;
			case 'b':
				black_score += 3;
				break;
			case 'N':
				white_score += 3;
				break;
			case 'n':
				black_score += 3;
				break;
			default:
				break;
			}
		}
	}
	return white_score - black_score;
}
```
### 9.4 节
#### 14
形参位置互换，逻辑错误，else分支删除，在for循环外加上return false
#### 15
```c
double median(double x, double y, double z)
{
	int res;
	if (x <= y)
		if (y <= z) res = y;
		else if (x <= z) res = z;
		else res = x;
	if (z <= y) res = y;
	if (x <= z) res = x;
	res = z;
	return res;
}
```
### 9.6节
#### 16
```c
int fact(int n)
{
	return (n <= 1) ? 1 : n * fact(n - 1);
}
```
#### 17
```c
void fact(int n)
{
	int res = 1;
	while (n > 0)
	{
		res = res * n;
		n--;
	}
	printf("Factorial is %d", res);
}
```
#### 18
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int gcd(int m, int n);
int main()
{
	int a, b;
	printf("请输入两个正整数，以空格隔开：");
	scanf_s("%d %d", &a, &b);
	gcd(a, b);
	return 0;
}
int gcd(int m, int n)
{
		if (n == 0) {
			printf("最大公约数是：%d\n", m);
			return m;
		}
		else {
			gcd(n, m%n);
		}
}
```
#### 19
略
## 编程题
### 1
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define LENGTH 5
void selection_sort(int n, int a[]);
int main()
{
	int a[LENGTH] = {0};
	for (int i = 0; i < 5; i++)
	{
		scanf("%d", &a[i]);
	}
    selection_sort(LENGTH, a);
	for (int i = 0; i < 5; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
void selection_sort(int n, int a[])
{
    // 1. 递归终止条件
    if (n <= 1) return;

    // 2. 找到当前范围[0, n-1]中最大值的索引
    int max_index = 0;
    for (int i = 1; i < n; i++)
    {
        if (a[i] > a[max_index])  // 找最大值
        {
            max_index = i;
        }
    }

    // 3. 交换：把最大值放到最后
    int temp = a[max_index];
    a[max_index] = a[n - 1];  // 把原来最后位置的元素放到max_index处
    a[n - 1] = temp;          // 把最大值放到最后

    // 4. 递归排序前n-1个元素
    selection_sort(n - 1, a);
}
```
### 2
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
void calculate_tax(float income) {
	if (income <= 750)
		printf("tax:%f\n", income * 0.01);
	else if (income > 750 && income <= 2250)
		printf("tax:%f\n", 7.5 + (income - 750) * 0.02);
	else if (income > 2250 && income <= 3750)
		printf("tax:%f\n", 37.5 + (income - 2250) * 0.03);
	else if (income > 3750 && income <= 5250)
		printf("tax:%f\n", 82.5 + (income - 3750) * 0.04);
	else if (income > 5250 && income <= 7000)
		printf("tax:%f\n", 142.5 + (income - 5250) * 0.05);
	else if (income > 7000)
		printf("tax:%f\n", 230 + (income - 7000) * 0.06);
}
int main() {
	float income;
	printf("Enter income: ");
	scanf("%f", &income);
	calculate_tax(income);
}
```
### 3
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
#include <time.h>
#include <stdlib.h>

#define SIZE 10
#define DIRECTIONS 4

void generate_random_walK(char grid[][SIZE]);
void generate_random_walk(char grid[][SIZE])
{
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            grid[i][j] = '.';
        }
    }

    int x = 0, y = 0;
    int direction, new_x, new_y;
    int moves_tried;
    char current_char = 'A';

    // 从(0,0)开始
    grid[x][y] = current_char++;

    // 随机行走直到Z或者被卡住
    while (current_char <= 'Z') {
        int possible_directions[DIRECTIONS] = { 0, 1, 2, 3 }; // 0:上, 1:下, 2:左, 3:右
        int tried[DIRECTIONS] = { 0 }; // 记录哪些方向已经尝试过
        moves_tried = 0;

        // 随机尝试四个方向
        while (moves_tried < DIRECTIONS) {
            // 随机选择一个未尝试的方向
            int rand_index;
            do {
                rand_index = rand() % DIRECTIONS;
            } while (tried[rand_index]);

            direction = possible_directions[rand_index];
            tried[rand_index] = 1;
            moves_tried++;

            // 计算新位置
            new_x = x;
            new_y = y;

            switch (direction) {
            case 0: // 上
                new_x--;
                break;
            case 1: // 下
                new_x++;
                break;
            case 2: // 左
                new_y--;
                break;
            case 3: // 右
                new_y++;
                break;
            }

            // 检查新位置是否有效
            if (new_x >= 0 && new_x < SIZE &&
                new_y >= 0 && new_y < SIZE &&
                grid[new_x][new_y] == '.') {
                // 移动到新位置
                x = new_x;
                y = new_y;
                grid[x][y] = current_char++;
                break; // 成功移动，跳出内层循环
            }
        }

        // 如果四个方向都尝试过且都不能移动，则终止
        if (moves_tried == DIRECTIONS) {
            break;
        }
    }
    printf("\n到达的字母: A 到 %c\n", current_char - 1);
}
int main(void) {
    char grid[SIZE][SIZE];
    

    // 初始化随机数种子
    srand((unsigned)time(NULL));

    // 初始化网格为'.'
    generate_random_walk(grid);

    // 打印最终的网格
    printf("最终的随机步法网格:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%c ", grid[i][j]);
        }
        printf("\n");
    }

    

    return 0;
}
```
### 4
```C
#include <stdio.h>
#include <ctype.h>
#define _CRT_SECURE_NO_WARNINGS
#define ALPHABET_SIZE 26

void read_word(int counts[26]);
bool equal_array(int counts1[26], int counts2[26]);
void read_word(int counts[26])
{
    char ch;
    while ((ch = getchar()) != '\n' && ch != EOF) {
        if (isalpha(ch)) {
            ch = tolower(ch);
            counts[ch - 'a']++;
        }
	}
}
bool equal_array(int counts1[26], int counts2[26])
{
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        if (counts1[i] != counts2[i]) {
            return false;
        }
    }
	return true;
}
int main(void) {
    char ch;
    int letter_count1[ALPHABET_SIZE] = { 0 };
    int letter_count2[ALPHABET_SIZE] = { 0 };
    // 读取并统计第一个单词
    printf("Enter first word: ");
    read_word(letter_count1);
    // 读取并统计第二个单词
    printf("Enter second word: ");
    read_word(letter_count2);

    bool flag;
    flag = equal_array(letter_count1,letter_count2);
    if (flag) {
        printf("The words are anagrams.\n");
    }
    else {
        printf("The words are not anagrams.\n");
    }

    return 0;
}
```
### 5
略
### 6
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int main(void) {
    int x;
	scanf("%d", &x);
	int res = 3 * x * x * x * x * x + 2 * x * x * x * x - 5 * x * x *x - x * x+ 7*x-6;
	printf("%d\n", res);
    return 0;
}
```
### 7
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>

// 使用long long避免溢出
long long cal(int x, int n);

int main(void)
{
    int x, n;

    // 修改输入提示和格式
    printf("请输入x和n（用空格分隔）: ");
    scanf("%d %d", &x, &n);

    if (n < 0) {
        printf("错误：n不能为负数\n");
        return 1;
    }

    long long result = cal(x, n);
    printf("%d^%d = %lld\n", x, n, result);

    return 0;
}

// 使用快速幂算法
long long cal(int x, int n)
{
    if (n == 0)
        return 1;

    // 计算 x^(n/2)
    long long half = cal(x, n / 2);

    if (n % 2 == 0) {
        // n为偶数：x^n = (x^(n/2))^2
        return half * half;
    }
    else {
        // n为奇数：x^n = x * (x^(n/2))^2
        // 注意：n/2 是整数除法，n=5时，n/2=2
        return x * half * half;
    }
}
```
### 8
略
